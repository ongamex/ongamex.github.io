---
title:  "C++ reflection/introspection system"
date:   2017-09-28
categories: C++
tags: [C++]
excerpt: "A way to implement reflections in C++!"
---

As some of you may know, I'm writing a game+content creation tool in my spare time. 
In order to reduce the number of lines that I need to write, I needed a reflection system in C++, so I could ask questions like:   
*"What members are in this struct?"*,  
*"Is Type::member something that is game related?"*,  
*"Is Type::member something that should be visible in the UI?"*,  
*"Is Type::member something that should be saved to the game's level files?"*,  
**...I could continue forever with that list.*  

Unfortunately C++ doesn't have any built-in reflection system yet. Until then we are on our own.  
There are few libraries out there that does a similar thing, however form those that I found, 
some of them had missing features and some of there were too complicated.

The minimum set of features that I need in order to benefit form such system are:
* The reflection system shouldn't change the way I write structs and classes. I don't want to wrap my members with tons and tons of macros and templates.
* The compile time should remain unchanged.
* The described data should be correct.
* The data should be available at runtime.
* I should be able to add custom tags and attributes.

Here is the code + an example: [https://github.com/ongamex/blog.reflections](https://github.com/ongamex/blog.reflections)  
While reading it please keep in mind that this is directly taken form my codebase,
and some of the names/prefixes may not look ideal.  

And here is an image of the reflection system in use for the UI:
![](/assets/images/gamewip.png)  

Instead of explaining you how it works(actually the code is explained in the example repository). I'll show you an example usage.
The idea of the reflection system is to create a place to store descriptions of types (in the case of the example a global variable).
The somewhere in the beginning of you main function we register all the types that we need to the reflection. We could do that by hand 
or write/use a tool that parses the code and generates it for us. For simplicity I do it by hand(actually in practice I still do it by hand).

```cpp
struct Data
{
	int x;
	char y;
	float z;
	MyEnum myEnumValue = myEnum_value0;
};

struct DataWithBaseClass : public Data
{
	std::string str = "hello!";
	quaternion quat;
};

// ...

int main()
{
	// Register our types, by hand or with some tool that generates the code for us.
	#define REGISTER_TYPE(type) g_typeRegister.registerType<type>(#type)
	#define MEMBER(TStruct, TMember) .member(#TMember, &TStruct::TMember)	

	REGISTER_TYPE(Data)
		.constructable<Data>().copyable<Data>()
		MEMBER(Data, x) 
		MEMBER(Data, y)
		MEMBER(Data, z)
		MEMBER(Data, myEnumValue);

	REGISTER_TYPE(DataWithBaseClass)
		.inherits<Data>()
		.constructable<DataWithBaseClass>().copyable<DataWithBaseClass>()
		MEMBER(DataWithBaseClass, str) 
		MEMBER(DataWithBaseClass, quat);

	// The program continues ....
	
	// Use the reflection as you like.
	foo(g_typeRegister.find<Data>()->name);
	bar(g_typeRegister.find<data>()->members[0].byteOffset);
}

```

Future improvements:  
* Multiple inheritance (this is in my TODO-list, I just don't need it currently).
* Enum values.
* Cross DLL safety.
* Checks if the type is fully described. (Not really needed now that I think about it, but for completeness).
* A tool that generates the description for us. This isn't directly linked to the reflection system. Examples are
[https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection](https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection) or here
[http://onqtam.com/programming/2017-09-02-simple-cpp-reflection-with-cmake](http://onqtam.com/programming/2017-09-02-simple-cpp-reflection-with-cmake)
  
I welcome all feedback and feature request, so do not hesitate to ask in the section below ^_^
  
  